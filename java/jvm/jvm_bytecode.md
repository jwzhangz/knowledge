在Java虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型称为各种虚拟机执行引擎的统一外观（Facade）。在不同的虚拟机实现里面，执行引擎在执行Java代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择，也可能两者兼备，甚至还可能会包含几个不同级别的编译器执行引擎。但从外观上看起来，所有的Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。

### 运行时栈帧结构
栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

编译代码的时候，栈帧需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

#### 1. 局部变量表
存放方法参数和方法内部定义的局部变量。Java程序编译为class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。

局部变量表的容量以变量槽（Variable Slot）为最小单位，虚拟机规范中并没有明确指定一个Slot应占用多少内存，只是说每个Slot应该能存放一个boolean、byte、char、short、int、float、reference、或returnAddress类型的数据。以上8种数据类型都是32位以内的。对于64位数据类型，虚拟机会以高位对齐的方式为其分配两个连续的Slot空间。

虚拟机通过索引定位方式使用局部变量表，索引值从0开始至最大Slot数量。如果访问32位数据类型变量，索引n就代表使用了第n个Slot，如果是64位数据类型的变量，则同时使用n和n+1两个Slot。对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中的一个，Java虚拟机规范中明确要求了如果遇到进行这种操作的字节码序列，虚拟机应该在类加载的校验阶段抛出异常。

#### 2. 操作数栈
操作数栈（Operand Stack）也常称为操作栈，是一个后入先出（LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1,64位数据类型所占的栈容量为2。

当一个方法刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入或提取内容，也就是入栈/出栈操作。

