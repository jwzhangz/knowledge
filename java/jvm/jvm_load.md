类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。

加载-->验证-->准备-->解析-->初始化-->使用-->卸载

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)。

Java虚拟机并没有强制约束什么时候开始加载，由虚拟机具体实现来自由把握。

虚拟机规范规定，有且只有5种情况必须立即对类进行“初始化”(而加载、验证、准备自然需要在此之前)：
1. 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则先要初始化。生成这4条指令的最常见的场景是：使用new关键字实例化对象，读取或设置一个类的静态字段(被final修饰、已在编译期把结果放入常量池的静态字段除外)的时候，以及调用一个类的静态方法的时候。
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则先要触发其初始化。
3. 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
4. 当虚拟机启动时，用户需要指定一个要执行的主类(包含main方法的那个类)，虚拟机会先初始化这个类。
5. 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。

这5种场景中的行为称为对一个类进行主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。


## 类加载的过程
Java虚拟机中类加载的全过程，包括加载、验证、准备、解析和初始化这5个阶段所执行的具体动作。

### 加载
加载是类加载的一个阶段。在加载阶段，虚拟机需要完成3件事：
1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式由虚拟机实现自行定义，虚拟机规范未规定此区域的具体数据结构。然后再内存中实例化一个java.lang.Class类的对象（并没有明确规定是在Java堆中，对于HotSpot虚拟机而言，Class对象比较特殊，它虽然是对象，但放在方法区里面），这个对象将作为程序访问方法区中的这些类型数据的外部接口。

加载阶段和连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于验证阶段的内容。

### 验证
验证是连接阶段的第一步，这一阶段的目的是确保Class文件的字节流中包含的信息符合虚拟机要求，并且不会危害虚拟机安全。

### 准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在**方法区**中进行分配。这时候进行内存分配的仅包括类变量（被static修饰的变量），不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中。初始值“通常”情况下是数据类型的零值。假设一个类变量定义为：
public static int value = 123;
变量value在准备阶段后初始值为0而不是123，因为这时还没有执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法中，所以把value赋值为123的动作将在初始化阶段才会执行。

相对于“通常情况”，还会有“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，例如：
public static final int value = 123;
编译阶段就会为value生成ConstantValue属性。
